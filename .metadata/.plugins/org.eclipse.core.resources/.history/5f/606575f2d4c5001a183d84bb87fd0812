package toy_project;

import java.util.*;

public class PlayThread extends Thread {
	private static boolean block_finish = false;

	private List<Point> b;
	private int[][] board = new int[20][10];
	private int[] ud = { 1, 0, 0 };
	private int[] rl = { 0, -1, 1 };
	public static int dir = 0;
	public static long time = 1000;
	public static int removed_line = 0;
	private tetris_board tetris_board;

	@Override
	public void run() {
		tetris_board = new tetris_board();
		tetris_block block = new tetris_block();
		tetris_board.set_board(board);

		while (true) {
			try {
				if (!block_finish) {
					Random rand = new Random();
					int n = rand.nextInt(7);
					b = block.make_block(n);

					tetris_board.set_block(b);
					block_finish = true;
				}

				Thread.sleep(1);
				if (dir < 3) {
					// 벽에 부딪히고 움직이지 않는 경우
					if (!move()) {
						dir = -1;
						move();
					}
				} else if (dir == 3) // 위 키를 누른 경우
					rotate();
				else if (dir == 32) { // 스페이스 바를 누른 경우
					dir = 0;
					while (true) {
						if (!move()) {
							break;
						}
					}
				}
				tetris_board.repaint();
				dir = -1;
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private void print() {
		for (int i = 0; i < 20; i++) {
			for (int j = 0; j < 10; j++) {
				System.out.print(board[i][j] + " ");
			}
			System.out.println();
		}
		System.out.println();
	}

	/*
	 * 블록 회전 하는 메소드 회전 변환 행렬을 이용하여 회전
	 */
	private void rotate() {
		int pivot_x = 0, pivot_y = 0;
		int x_minor = Integer.MAX_VALUE, y_minor = Integer.MAX_VALUE;
		int x_maxer = 0, y_maxer = 0;

		for (Point p : b) {
			x_minor = Math.min(x_minor, p.x);
			y_minor = Math.min(y_minor, p.y);

			x_maxer = Math.max(x_maxer, p.x);
			y_maxer = Math.max(y_maxer, p.y);
		}

		pivot_x = x_minor + (x_maxer-x_minor) / 2;
		pivot_y = y_minor + (y_maxer-y_minor) / 2;

		for (Point p : b) {
			p.x = p.x - pivot_x;
			p.y = p.y - pivot_y;
		}

		int x_min = 0, x_max = 9, y_max = 19, y_min = 0;
		for (Point p : b) {
			int nx = p.x * 0 + -1 * p.y;
			int ny = p.x * 1 + 0 * p.y;

			p.x = nx + pivot_x;
			p.y = ny + pivot_y;

			if (p.x < 0)
				x_min = Math.min(p.x, x_min);

			if (p.x >= 10)
				x_max = Math.max(p.x, x_max);

			if (p.y < 0)
				y_min = Math.min(p.y, y_min);

			if (p.y >= 20)
				y_max = Math.max(p.y, y_max);
		}

		x_min = Math.abs(x_min);
		y_min = Math.abs(y_min);

		for (Point p : b) {
			p.x += x_min;
			p.y += y_min;
		}

		x_max -= 9;
		y_max -= 19;

		for (Point p : b) {
			p.x -= x_max;
			p.y -= y_max;
		}
	}

	private void remove_line() {
		Set<Integer> idx = new LinkedHashSet<>();
		for (int i = 0; i < 20; i++) {
			int count = 0;
			for (int j = 0; j < 10; j++) {
				if (board[i][j] == 1)
					count++;
			}

			if (count == 10) {
				Arrays.fill(board[i], 0);
				idx.add(i);
			}
		}

		removed_line += idx.size();
		for (int i : idx) {
			for (int j = i - 1; j >= 0; j--) {
				for (int k = 0; k < 10; k++) {
					if (board[j][k] == 1) {
						board[j][k] = 0;
						board[j + 1][k] = 1;
					}
				}
			}
		}

	}

	private boolean move() {
		boolean check = true;

		if (dir != -1) {
			for (Point p : b) {
				int nx = p.y + ud[dir];
				int ny = p.x + rl[dir];

				// 테트리스 블록이 배열 범위 밖으로 넘어갈 경우
				if (nx < 0 || nx >= 20 || ny < 0 || ny >= 10) {
					if (nx < 0 || nx >= 20) {
						block_finish = false;
						board_print();
						remove_line();
					}
					check = false;
					return check;
				}

				// 테트리스 블록이 존재할 경우
				if (board[nx][ny] == 1) {
					// 방향이 아랫방향일 경우
					if (dir == 0) {
						block_finish = false;
						board_print();
						remove_line();
					}
					check = false;
					return check;
				}
			}

			if (check) {
				for (Point p : b) {
					p.y += ud[dir];
					p.x += rl[dir];
				}
			}
		}
		return check;
	}

	// 보드판에 블록 추가
	private void board_print() {
		for (Point p : b) {
			board[p.y][p.x] = 1;
		}
	}
}
