package genetic_tetris;

import java.util.*;

public class calculate_gene {
	private int[][] board;
	private int[] ud = { -1, 0, 1, 0 };
	private int[] rl = { 0, 1, 0, -1 };

	public void calculate(List<Point> tmp, int n, int[][] board, Weight w) {
		this.board = board;

		// 현재 블럭으로 채우기
		for (Point p : tmp) {
			board[p.x][p.y] = n;
		}

	}

	private int hole_count(List<Point> tmp) {
		boolean [][] visited=  new boolean[20][10];
		for(int i =0 ; i < 20 ; i++) {
			for(int j =0 ; j < 10 ; j++) {
				if(board[i][j] != 0)
					visited[i][j] = true;
			}
		}
		
		bfs(visited,0,4);
		
		int ret =0;
		
		
		for(int i =0 ; i < 20 ; i++) {
			for(int j =0 ; j< 10 ; j++) {
				if(!visited[i][j])
					ret++;
			}
		}
		
		return ret;
	}
	
	private void bfs(boolean [][] visited , int x ,int y) {
		Queue<Point> q = new LinkedList<>();
		q.add(new Point(x,y));
		visited[x][y]=  true;
		
		while(!q.isEmpty()) {
			Point cur = q.poll();
			
			for(int i = 0 ; i < 4 ; i++) {
				int nx = cur.x + ud[i];
				int ny = cur.y + rl[i];
				
				if(nx <0 || nx >= 20 || ny < 0 || ny>= 10 || visited[nx][ny])
					continue;
				
				visited[nx][ny]=  true;
				q.add(new Point(nx,ny));
			}
		}
		
	}
	
	//아래 접하는 블럭
	private int below_block(List<Point> tmp) {
		
		int ret =0 ;
		
		for (Point p : tmp) {
			int nx = p.x + 1;
			int ny = p.y;
			
			if(nx <0 || nx >= 20 || ny < 0 || ny>= 10 || board[nx][ny] == 0)
				continue;

			ret++;
		}
		
		return ret;
	}

	private int side_block(List<Point> tmp) {
		int ret = 0;
		for (Point p : tmp) {
			for (int i = 0; i < 4; i++) {
				if (i % 2 != 0) {
					int nx = p.x + ud[i];
					int ny = p.y + rl[i];

					if (nx < 0 || nx >= 20 || ny < 0 || ny >= 10) {
						ret++;
						continue;
					}

					if (board[nx][ny] != 0)
						ret++;
				}
			}
		}

		return ret;
	}

	private int down_blank(List<Point> tmp) {
		int ret = 0;
		for (Point p : tmp) {
			int curX = p.x;
			while (true) {
				int nx= curX + 1;
				int ny = p.y;
				if (nx < 0 || nx >= 20 || ny < 0 || ny >= 10 || board[nx][ny] != 0)
					break;
				ret++;
				curX = nx;
			}
		}

		return ret;
	}

	private int cal_height(List<Point> tmp) {
		int height = Integer.MAX_VALUE;

		for (Point p : tmp) {
			height = Math.min(height, p.x);
		}

		return height;
	}

	private int round_block(List<Point> tmp) {
		boolean[][] visited = new boolean[20][10];

		for (Point p : tmp) {
			visited[p.x][p.y] = true;
		}

		int ret = 0;
		for (Point p : tmp) {
			for (int i = 0; i < 4; i++) {
				int nx = p.x + ud[i];
				int ny = p.y + rl[i];

				if (nx < 0 || nx >= 20 || ny < 0 || ny >= 10 || visited[nx][ny] || board[nx][ny] == 0)
					continue;

				visited[nx][ny] = true;
				ret++;
			}
		}

		return ret;
	}

	private int complete_line() {
		int ret = 0;
		for (int i = 0; i < 20; i++) {
			int count = 0;
			for (int j = 0; j < 10; j++) {
				if (board[i][j] != 0)
					count++;
			}

			if (count == 10)
				ret++;
		}

		return ret;
	}

	private int blank_count(List<Point> tmp) {
		boolean[][] visited = new boolean[20][10];
		for (Point p : tmp) {
			visited[p.x][p.y] = true;
		}

		int ret = 0;
		for (Point p : tmp) {
			for (int i = 0; i < 4; i++) {
				int nx = p.x + ud[i];
				int ny = p.y + rl[i];

				if (nx < 0 || nx >= 20 || ny < 0 || ny >= 10 || visited[nx][ny] || board[nx][ny] != 0)
					continue;

				visited[nx][ny] = true;
				ret++;
			}
		}

		return ret;
	}
}
